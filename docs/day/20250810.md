>设计文档：
> 一、项目背景与目标
在电商运营中，商品的访问、收藏、加购、销售等数据是商家判断经营状况、调整策略的核心依据。为帮助电商商家实时掌握全店商品动态，及时察觉销售异常并进行精细化运营，特设计本商品主题宏观监控看板，通过整合商品全链路数据，提供直观、多维的分析视角。
二、核心功能模块设计
1. 商品效率监控模块
   （1）数据维度与时间粒度
   监控范围：覆盖全店商品的动销情况、收藏加购数据、访问行为，支持实时与离线数据展示（本次暂不实现实时功能）。
   时间维度：提供 7 天、30 天、日、周、月及自定义周期（自定义周期需手动输入起止日期），满足不同时段的趋势分析需求。
   （2）可视化展示
   趋势图：选择日维度时，以时段柱形图展示当日各时段的核心指标（如每小时访客数、支付金额）；选择周 / 月维度时，以折线图呈现指标变化趋势，支持多指标对比（如同时展示浏览量与支付金额曲线）。
   异常预警：当指标波动超过预设阈值（如支付金额较前日下降 30%），图表自动标记异常点并提示，帮助商家快速定位问题。
2. 商品区间分析模块
   （1）区间划分维度
   支持按以下指标自定义区间划分，且分档无需动态配置，采用固定区间（如支付件数分为 0~50、51~100、101~150 等）：

价格带（如 0~50 元、51~100 元、101~200 元）；
支付件数（如 0~50 件、51~100 件）；
支付金额（如 0~1000 元、1001~5000 元）。
（2）分析粒度与排序
类目粒度：细分至叶子类目（如 “服饰 - 男装 - T 恤”“电子 - 手机 - 智能手机”），支持按类目筛选数据。
排序指标：可按动销商品数、支付金额、支付件数、件单价等指标排序，快速定位高价值区间。
三、关键指标体系
基于商品全链路行为，看板整合以下核心指标，指标定义严格遵循业务逻辑：

指标类型	核心指标	定义说明
访问行为指标	商品访客数、浏览量、平均停留时长、跳出率	访客数为访问详情页的去重人数；跳出率 = 无点击行为人数 / 访客数，值越低越好。
收藏加购指标	收藏人数、加购人数、加购件数、访问收藏转化率、访问加购转化率	收藏 / 加购人数为新增行为去重人数；转化率 = 收藏 / 加购人数 / 访客数。
交易转化指标	下单买家数、支付买家数、支付金额、支付转化率、客单价	支付转化率 = 支付买家数 / 商品访客数（仅统计访问详情页的访客）；客单价 = 支付金额 / 支付买家数。
用户分层指标	支付新买家数、支付老买家数、老买家支付金额	新买家指近 365 天无支付行为的用户，老买家反之。
四、技术实现要点
数据来源：基于电商数仓 ODS 层与 DWD 层数据，整合商品基础信息、访问行为、交易记录等明细数据，确保指标计算的准确性。
存储与计算：采用 ORC 格式存储数据，支持分区查询（按日期分区），提升查询效率；通过 Hive SQL 实现指标聚合，确保数据更新延迟控制在 1 小时内（离线数据）。
交互设计：支持指标筛选、时间维度切换、类目下钻等交互功能，响应时间不超过 2 秒，提升用户体验。
五、产出物说明
商品宏观监控看板设计文档：包含功能模块说明、指标定义、界面原型图、交互逻辑说明。
商品宏观监控看板代码：涵盖数据抽取（ETL）脚本、指标计算 SQL、前端可视化代码，代码注释需包含工单编号 “大数据 - 电商数仓 - 01 - 商品主题宏观监控看板”。
商品宏观监控看板测试文档：包含功能测试用例、性能测试报告（如并发查询响应时间）、数据准确性校验结果。
商品宏观监控看板上线截图：展示实际运行界面，包括趋势图、区间分析表等核心模块的最终效果。
六、项目价值
本看板通过整合商品全链路数据，为电商商家提供 “监控 - 分析 - 决策” 的闭环支持：

实时察觉销售异常，降低经营风险；
精细化分析商品区间与类目表现，优化资源分配；
基于数据指标调整运营策略，提升商品转化率与销售额。

通过标准化的指标体系与直观的可视化展示，助力商家实现数据驱动的精细化运营。

>通过文档设计我们生成的表格
>create database if not exists new01;
use new01;

CREATE TABLE IF NOT EXISTS ods_product_base (
product_id STRING COMMENT '商品ID（唯一标识）',
product_name STRING COMMENT '商品名称',
category_leaf STRING COMMENT '叶子类目（如：服饰-男装-T恤）',
price DECIMAL(10,2) COMMENT '商品价格（元）',
create_time STRING COMMENT '商品创建时间（yyyy-MM-dd）'
)
COMMENT 'ODS层-商品基础信息表'
PARTITIONED BY (dt STRING COMMENT '分区日期（统计数据的日期）')
STORED AS ORC
LOCATION '/warehouse/macro/ods_product_base/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');


CREATE TABLE IF NOT EXISTS ods_product_visit (
product_id STRING COMMENT '商品ID（关联ods_product_base）',
stat_period STRING COMMENT '统计周期（与dt一致，yyyy-MM-dd）',
visitor_count INT COMMENT '商品访客数（去重，访问详情页的人数）',
view_count INT COMMENT '商品浏览量（详情页被浏览次数）',
avg_stay_time INT COMMENT '平均停留时长（秒，总停留时长/访客数）',
bounce_rate DECIMAL(3,2) COMMENT '详情页跳出率（无点击行为人数/访客数）'
)
COMMENT 'ODS层-商品访问行为表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/ods_product_visit/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');


CREATE TABLE IF NOT EXISTS ods_product_collect_cart (
product_id STRING COMMENT '商品ID（关联ods_product_base）',
stat_period STRING COMMENT '统计周期（yyyy-MM-dd）',
collect_user_count INT COMMENT '收藏人数（新增收藏去重人数）',
add_cart_user_count INT COMMENT '加购人数（新增加购去重人数）',
add_cart_item_count INT COMMENT '加购件数（新增加入购物车的总件数）'
)
COMMENT 'ODS层-商品收藏加购表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/ods_product_collect_cart/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');


CREATE TABLE IF NOT EXISTS ods_product_trade (
product_id STRING COMMENT '商品ID（关联ods_product_base）',
stat_period STRING COMMENT '统计周期（yyyy-MM-dd）',
order_user_count INT COMMENT '下单买家数（去重，拍下商品的人数）',
order_item_count INT COMMENT '下单件数（拍下商品的总件数）',
order_amount DECIMAL(10,2) COMMENT '下单金额（拍下商品的总金额，元）',
pay_user_count INT COMMENT '支付买家数（去重，完成支付的人数）',
pay_item_count INT COMMENT '支付件数（完成支付的总件数）',
pay_amount DECIMAL(10,2) COMMENT '支付金额（实际支付总金额，未剔除退款，元）',
refund_amount DECIMAL(10,2) COMMENT '成功退款退货金额（元）',
pay_new_user_count INT COMMENT '支付新买家数（近365天无支付行为的买家）',
pay_old_user_count INT COMMENT '支付老买家数（近365天有支付行为的买家）',
old_user_pay_amount DECIMAL(10,2) COMMENT '老买家支付金额（老买家的支付总金额，元）',
juhuasuan_pay_amount DECIMAL(10,2) COMMENT '聚划算支付金额（活动产生的支付金额，元）'
)
COMMENT 'ODS层-商品下单支付表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/ods_product_trade/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');


-- [08S01][1] Error while processing statement:
-- FAILED: Execution Error, return code 1 from
-- org.apache.hadoop.hive.ql.exec.StatsTask解决

-- 这个问题是在执行Hive SQL语句时出现的执行错误，错误代码为1
-- ，来源于org.apache.hadoop.hive.ql.exec.StatsTask。
-- 这个错误通常不是SQL语法错误，而是与Hive执行过程中的统计
-- 信息收集或底层系统问题有关。


SET hive.stats.autogather=false;
-- 然后重新执行你的INSERT语句
SET hive.exec.compress.output=false;
SET hive.exec.dynamic.partition.mode=nonstrict;
SET hive.tez.container.size=1024;
-- 临时禁用ORC压缩测试


INSERT INTO TABLE ods_product_base PARTITION (dt = '2025-08-12')
SELECT
CONCAT('P', LPAD(CAST(pos + 1 AS STRING), 5, '0')) AS product_id,  -- 商品ID：P00001~P10000
CONCAT('商品', LPAD(CAST(pos + 1 AS STRING), 5, '0')) AS product_name,  -- 商品名称
CASE CAST(RAND() * 4 AS INT)  -- 随机叶子类目
WHEN 0 THEN '服饰-男装-T恤'
WHEN 1 THEN '电子-手机-智能手机'
WHEN 2 THEN '家居-厨具-炒锅'
ELSE '美妆-护肤-面霜'
END AS category_leaf,
ROUND(RAND() * 990 + 10, 2) AS price,  -- 价格：10~1000元
DATE_FORMAT(DATE_ADD('2025-08-10', -CAST(RAND() * 365 AS INT)), 'yyyy-MM-dd') AS create_time  -- 近1年创建时间
FROM (
SELECT pos FROM (SELECT posexplode(split(space(9999), ' ')) AS (pos, val)) t  -- 生成0~9999共10000条
) t;


INSERT INTO TABLE ods_product_visit PARTITION (dt = '2025-08-12')
SELECT
CONCAT('P', LPAD(CAST(pos + 1 AS STRING), 5, '0')) AS product_id,  -- 关联商品ID
'2025-08-10' AS stat_period,  -- 统计日期
CAST(RAND() * 950 + 50 AS INT) AS visitor_count,  -- 访客数：50~1000
CAST(visitor_count * (RAND() * 3 + 1) AS INT) AS view_count,  -- 浏览量：访客数1~4倍
CAST(RAND() * 290 + 10 AS INT) AS avg_stay_time,  -- 停留时长：10~300秒
ROUND(RAND() * 0.6 + 0.1, 2) AS bounce_rate  -- 跳出率：0.1~0.7
FROM (
SELECT pos, CAST(RAND() * 950 + 50 AS INT) AS visitor_count
FROM (SELECT posexplode(split(space(9999), ' ')) AS (pos, val)) t
) t;

INSERT INTO TABLE ods_product_collect_cart PARTITION (dt = '2025-08-12')
SELECT
CONCAT('P', LPAD(CAST(pos + 1 AS STRING), 5, '0')) AS product_id,  -- 关联商品ID
'2025-08-10' AS stat_period,
CAST(visitor_count * (RAND() * 0.2 + 0.05) AS INT) AS collect_user_count,  -- 收藏人数：访客数5%~25%
CAST(visitor_count * (RAND() * 0.3 + 0.1) AS INT) AS add_cart_user_count,  -- 加购人数：访客数10%~40%
CAST((CAST(visitor_count * (RAND() * 0.3 + 0.1) AS INT) ) * (RAND() * 2 + 1) AS INT) AS add_cart_item_count  -- 加购件数：加购人数1~3倍
FROM (
SELECT pos, CAST(RAND() * 950 + 50 AS INT) AS visitor_count  -- 复用访客数范围（与访问表逻辑一致）
FROM (SELECT posexplode(split(space(9999), ' ')) AS (pos, val)) t
) t;


INSERT INTO TABLE ods_product_trade PARTITION (dt = '2025-08-12')
SELECT
product_id,
'2025-08-10' AS stat_period,
order_user_count,
order_item_count,
order_amount,
CAST(order_user_count * (RAND() * 0.4 + 0.5) AS INT) AS pay_user_count,  -- 支付买家数：下单买家数50%~90%
CAST((CAST(order_user_count * (RAND() * 0.4 + 0.5) AS INT)) * (RAND() * 2 + 1) AS INT) AS pay_item_count,  -- 支付件数：支付买家数1~3倍
ROUND((CAST((CAST(order_user_count * (RAND() * 0.4 + 0.5) AS INT)) * (RAND() * 2 + 1) AS INT)) * price * (RAND() * 0.3 + 0.9), 2) AS pay_amount,  -- 支付金额：件数*单价*0.9~1.2倍
ROUND((ROUND((CAST((CAST(order_user_count * (RAND() * 0.4 + 0.5) AS INT)) * (RAND() * 2 + 1) AS INT)) * price * (RAND() * 0.3 + 0.9), 2)) * RAND() * 0.05, 2) AS refund_amount,  -- 退款金额：支付金额0~5%
CAST((CAST(order_user_count * (RAND() * 0.4 + 0.5) AS INT)) * (RAND() * 0.6 + 0.2) AS INT) AS pay_new_user_count,  -- 新买家占比20%~80%
(CAST(order_user_count * (RAND() * 0.4 + 0.5) AS INT)) - (CAST((CAST(order_user_count * (RAND() * 0.4 + 0.5) AS INT)) * (RAND() * 0.6 + 0.2) AS INT)) AS pay_old_user_count,  -- 老买家=总支付买家-新买家
ROUND(old_user_pay_ratio * (ROUND((CAST((CAST(order_user_count * (RAND() * 0.4 + 0.5) AS INT)) * (RAND() * 2 + 1) AS INT)) * price * (RAND() * 0.3 + 0.9), 2)), 2) AS old_user_pay_amount,  -- 老买家支付金额占比
ROUND((ROUND((CAST((CAST(order_user_count * (RAND() * 0.4 + 0.5) AS INT)) * (RAND() * 2 + 1) AS INT)) * price * (RAND() * 0.3 + 0.9), 2)) * RAND() * 0.3, 2) AS juhuasuan_pay_amount  -- 聚划算金额：支付金额0~30%
FROM (
SELECT
CONCAT('P', LPAD(CAST(pos + 1 AS STRING), 5, '0')) AS product_id,
CAST(RAND() * 300 + 20 AS INT) AS order_user_count,  -- 下单买家数：20~320
CAST((CAST(RAND() * 300 + 20 AS INT)) * (RAND() * 2 + 1) AS INT) AS order_item_count,  -- 下单件数：下单人数1~3倍
ROUND((CAST((CAST(RAND() * 300 + 20 AS INT)) * (RAND() * 2 + 1) AS INT)) * (ROUND(RAND() * 990 + 10, 2)) * (RAND() * 0.2 + 0.9), 2) AS order_amount,  -- 下单金额：件数*单价*0.9~1.1倍
ROUND(RAND() * 0.8 + 0.2, 2) AS old_user_pay_ratio,  -- 老买家支付金额占比：20%~100%
ROUND(RAND() * 990 + 10, 2) AS price  -- 复用商品价格范围（与基础表一致）
FROM (
SELECT pos FROM (SELECT posexplode(split(space(9999), ' ')) AS (pos, val)) t
) t1
) t2;


-- ====================================================dwd===================================================
-- DWD层：商品访问明细宽表（关联基础信息 + 访问行为）
CREATE TABLE IF NOT EXISTS dwd_product_visit_detail (
product_id STRING COMMENT '商品ID（关联ods_product_base）',
product_name STRING COMMENT '商品名称（来自ods_product_base）',
category_leaf STRING COMMENT '叶子类目（来自ods_product_base）',
stat_period STRING COMMENT '统计周期（与dt一致）',
visitor_count INT COMMENT '商品访客数',
view_count INT COMMENT '商品浏览量',
avg_stay_time INT COMMENT '平均停留时长',
bounce_rate DECIMAL(3,2) COMMENT '详情页跳出率'
)
COMMENT 'DWD层-商品访问明细宽表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/dwd_product_visit_detail/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');

-- 插入数据：关联ods_product_base + ods_product_visit
INSERT INTO TABLE dwd_product_visit_detail PARTITION (dt = '2025-08-12')
SELECT
pv.product_id,
pb.product_name,
pb.category_leaf,
pv.stat_period,
pv.visitor_count,
pv.view_count,
pv.avg_stay_time,
pv.bounce_rate
FROM ods_product_visit pv
JOIN ods_product_base pb
ON pv.product_id = pb.product_id
AND pv.dt = pb.dt  -- 关联同分区数据
WHERE pv.dt = '2025-08-12';

-- DWD层：商品收藏加购明细宽表（关联基础信息 + 收藏加购）
CREATE TABLE IF NOT EXISTS dwd_product_collect_cart_detail (
product_id STRING COMMENT '商品ID（关联ods_product_base）',
product_name STRING COMMENT '商品名称（来自ods_product_base）',
category_leaf STRING COMMENT '叶子类目（来自ods_product_base）',
stat_period STRING COMMENT '统计周期（与dt一致）',
collect_user_count INT COMMENT '收藏人数',
add_cart_user_count INT COMMENT '加购人数',
add_cart_item_count INT COMMENT '加购件数'
)
COMMENT 'DWD层-商品收藏加购明细宽表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/dwd_product_collect_cart_detail/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');

-- 插入数据：关联ods_product_base + ods_product_collect_cart
INSERT INTO TABLE dwd_product_collect_cart_detail PARTITION (dt = '2025-08-12')
SELECT
pcc.product_id,
pb.product_name,
pb.category_leaf,
pcc.stat_period,
pcc.collect_user_count,
pcc.add_cart_user_count,
pcc.add_cart_item_count
FROM ods_product_collect_cart pcc
JOIN ods_product_base pb
ON pcc.product_id = pb.product_id
AND pcc.dt = pb.dt  -- 关联同分区数据
WHERE pcc.dt = '2025-08-12';

select dt from dwd_product_collect_cart_detail where dt="2025-08-12";

-- DWD层：商品交易明细宽表（关联基础信息 + 下单支付）
CREATE TABLE IF NOT EXISTS dwd_product_trade_detail (
product_id STRING COMMENT '商品ID（关联ods_product_base）',
category_leaf STRING COMMENT '叶子类目（来自ods_product_base）',
stat_period STRING COMMENT '统计周期（与dt一致）',
order_user_count INT COMMENT '下单买家数',
order_item_count INT COMMENT '下单件数',
order_amount DECIMAL(10,2) COMMENT '下单金额',
pay_user_count INT COMMENT '支付买家数',
pay_item_count INT COMMENT '支付件数',
pay_amount DECIMAL(10,2) COMMENT '支付金额',
refund_amount DECIMAL(10,2) COMMENT '退款金额',
pay_new_user_count INT COMMENT '支付新买家数',
pay_old_user_count INT COMMENT '支付老买家数',
old_user_pay_amount DECIMAL(10,2) COMMENT '老买家支付金额',
juhuasuan_pay_amount DECIMAL(10,2) COMMENT '聚划算支付金额'
)
COMMENT 'DWD层-商品交易明细宽表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/dwd_product_trade_detail/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');

-- 插入数据：关联ods_product_base + ods_product_trade
INSERT INTO TABLE dwd_product_trade_detail PARTITION (dt = '2025-08-12')
SELECT
pt.product_id,
pb.category_leaf,
pt.stat_period,
pt.order_user_count,
pt.order_item_count,
pt.order_amount,
pt.pay_user_count,
pt.pay_item_count,
pt.pay_amount,
pt.refund_amount,
pt.pay_new_user_count,
pt.pay_old_user_count,
pt.old_user_pay_amount,
pt.juhuasuan_pay_amount
FROM ods_product_trade pt
JOIN ods_product_base pb
ON pt.product_id = pb.product_id
AND pt.dt = pb.dt  -- 关联同分区数据
WHERE pt.dt = '2025-08-12';

-- ====================================================dws===================================================
-- DWS层：商品销售汇总表（聚合交易、访问数据）
CREATE TABLE IF NOT EXISTS dws_product_sale_summary (
product_id STRING COMMENT '商品ID（关联DWD层）',
product_name STRING COMMENT '商品名称（来自DWD层）',
category_leaf STRING COMMENT '叶子类目（来自DWD层）',
stat_dt STRING COMMENT '统计日期（与dt一致）',
total_order_user INT COMMENT '总下单买家数',
total_pay_user INT COMMENT '总支付买家数',
total_pay_amount DECIMAL(10,2) COMMENT '总支付金额',
total_visitor INT COMMENT '总访客数',
total_view INT COMMENT '总浏览量',
avg_stay_time INT COMMENT '平均停留时长（秒）',
bounce_rate DECIMAL(3,2) COMMENT '详情页跳出率'
)
COMMENT 'DWS层-商品销售汇总表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/dws_product_sale_summary/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');

-- 插入数据：关联DWD交易表 + 访问表
INSERT INTO TABLE dws_product_sale_summary PARTITION (dt = '2025-08-12')
SELECT
dwd_trade.product_id,
dwd_visit.product_name,
dwd_trade.category_leaf,
dwd_trade.stat_period AS stat_dt,
dwd_trade.order_user_count AS total_order_user,
dwd_trade.pay_user_count AS total_pay_user,
dwd_trade.pay_amount AS total_pay_amount,
dwd_visit.visitor_count AS total_visitor,
dwd_visit.view_count AS total_view,
dwd_visit.avg_stay_time,
dwd_visit.bounce_rate
FROM dwd_product_trade_detail dwd_trade
JOIN dwd_product_visit_detail dwd_visit
ON dwd_trade.product_id = dwd_visit.product_id
AND dwd_trade.stat_period = dwd_visit.stat_period
AND dwd_trade.dt = dwd_visit.dt  -- 关联同商品、同日期
WHERE dwd_trade.dt = '2025-08-12';

-- DWS层：类目销售汇总表（按类目聚合）
CREATE TABLE IF NOT EXISTS dws_category_sale_summary (
category_leaf STRING COMMENT '叶子类目（来自DWD层）',
stat_dt STRING COMMENT '统计日期（与dt一致）',
total_product_cnt INT COMMENT '类目商品数',
total_order_user INT COMMENT '类目总下单买家数',
total_pay_user INT COMMENT '类目总支付买家数',
total_pay_amount DECIMAL(10,2) COMMENT '类目总支付金额',
avg_pay_amount DECIMAL(10,2) COMMENT '类目客单价（总支付金额/总支付买家数）'
)
COMMENT 'DWS层-类目销售汇总表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/dws_category_sale_summary/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');

-- 插入数据：聚合DWS商品销售汇总表
INSERT INTO TABLE dws_category_sale_summary PARTITION (dt = '2025-08-12')
SELECT
category_leaf,
stat_dt,
COUNT(DISTINCT product_id) AS total_product_cnt,
SUM(total_order_user) AS total_order_user,
SUM(total_pay_user) AS total_pay_user,
SUM(total_pay_amount) AS total_pay_amount,
ROUND(SUM(total_pay_amount) / NULLIF(SUM(total_pay_user), 0), 2) AS avg_pay_amount  -- 客单价=总支付金额/总支付买家数（避免除零）
FROM dws_product_sale_summary
WHERE dt = '2025-08-12'
GROUP BY category_leaf, stat_dt;


-- ADS层：商品销售排行表（按支付金额、销量排名）
CREATE TABLE IF NOT EXISTS ads_product_sale_rank (
product_id STRING COMMENT '商品ID（关联DWS层）',
product_name STRING COMMENT '商品名称（来自DWS层）',
category_leaf STRING COMMENT '叶子类目（来自DWS层）',
stat_period STRING COMMENT '统计周期（与dt一致）',
sales_rank INT COMMENT '销售额排名',
volume_rank INT COMMENT '销量排名',
total_pay_amount DECIMAL(10,2) COMMENT '总支付金额',
total_pay_qty INT COMMENT '总支付件数'
)
COMMENT 'ADS层-商品销售排行表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/ads_product_sale_rank/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');

-- 插入数据：基于DWS商品销售汇总表排行
INSERT INTO TABLE ads_product_sale_rank PARTITION (dt = '2025-08-12')
SELECT
product_id,
product_name,
category_leaf,
stat_dt,
-- 按类目分区，支付金额降序排名
RANK() OVER (PARTITION BY category_leaf ORDER BY total_pay_amount DESC) AS sales_rank,
-- 按类目分区，支付件数降序排名
RANK() OVER (PARTITION BY category_leaf ORDER BY total_pay_user DESC) AS volume_rank,
total_pay_amount,
total_pay_user AS total_pay_qty  -- 支付件数近似为支付买家数（可根据业务调整）
FROM dws_product_sale_summary
WHERE dt = '2025-08-12';


-- ADS层：类目销售分析表（展示类目核心指标）
CREATE TABLE IF NOT EXISTS ads_category_sale_analysis (
category_leaf STRING COMMENT '叶子类目（来自DWS层）',
stat_dt STRING COMMENT '统计日期（与dt一致）',
total_product_cnt INT COMMENT '类目商品数',
total_pay_amount DECIMAL(10,2) COMMENT '类目总支付金额',
avg_pay_amount DECIMAL(10,2) COMMENT '类目客单价',
max_sales_product STRING COMMENT '类目销售额最高商品',
max_volume_product STRING COMMENT '类目销量最高商品'
)
COMMENT 'ADS层-类目销售分析表'
PARTITIONED BY (dt STRING COMMENT '分区日期')
STORED AS ORC
LOCATION '/warehouse/macro/ads_category_sale_analysis/'
TBLPROPERTIES ('orc.compress' = 'SNAPPY');

-- 插入数据：关联DWS类目汇总 + 商品排行
-- 插入数据：关联DWS类目汇总 + 商品排行
INSERT INTO TABLE ads_category_sale_analysis PARTITION (dt = '2025-08-12')
SELECT
dws_category.category_leaf,
dws_category.stat_dt,
dws_category.total_product_cnt,
dws_category.total_pay_amount,
dws_category.avg_pay_amount,
-- 取类目销售额最高商品
MAX(CASE WHEN ads_rank.sales_rank = 1 THEN ads_rank.product_name END) AS max_sales_product,
-- 取类目销量最高商品
MAX(CASE WHEN ads_rank.volume_rank = 1 THEN ads_rank.product_name END) AS max_volume_product
FROM dws_category_sale_summary dws_category
JOIN ads_product_sale_rank ads_rank
ON dws_category.category_leaf = ads_rank.category_leaf
AND dws_category.stat_dt = ads_rank.stat_period  -- 修正字段名
WHERE dws_category.dt = '2025-08-12'
GROUP BY
dws_category.category_leaf,
dws_category.stat_dt,
dws_category.total_product_cnt,
dws_category.total_pay_amount,
dws_category.avg_pay_amount;

select count(*) from ods_product_base;
select count(*) from ods_product_collect_cart;
select count(*) from ods_product_trade;
select count(*) from ods_product_visit;
select count(*) from ads_category_sale_analysis;
select count(*) from ads_product_sale_rank;
select count(*) from dwd_product_trade_detail;
select count(*) from dwd_product_visit_detail;
select count(*) from dws_category_sale_summary;
select count(*) from dws_product_sale_summary;
>通过ads层数据分析，可以实现报表
> 